// path-to-regexp@8.3.0 downloaded from https://ga.jspm.io/npm:path-to-regexp@8.3.0/dist/index.js

var e={};Object.defineProperty(e,"__esModule",{value:true});e.PathError=e.TokenData=void 0;e.parse=c;e.compile=p;e.match=f;e.pathToRegexp=h;e.stringify=w;const t="/";const n=e=>e;const r=/^[$_\p{ID_Start}]$/u;const o=/^[$\u200c\u200d\p{ID_Continue}]$/u;const s={"{":"{","}":"}","(":"(",")":")","[":"[","]":"]","+":"+","?":"?","!":"!"};function a(e){return e.replace(/[{}()\[\]+?!:*\\]/g,"\\$&")}function i(e){return e.replace(/[.+*?^${}()[\]|/\\]/g,"\\$&")}class TokenData{constructor(e,t){this.tokens=e;this.originalPath=t}}e.TokenData=TokenData;class PathError extends TypeError{constructor(e,t){let n=e;t&&(n+=`: ${t}`);n+="; visit https://git.new/pathToRegexpError for info";super(n);this.originalPath=t}}e.PathError=PathError;function c(e,t={}){const{encodePath:a=n}=t;const i=[...e];const c=[];let p=0;let u=0;function l(){let t="";if(r.test(i[p]))do{t+=i[p++]}while(o.test(i[p]));else if(i[p]==='"'){let n=p;while(p++<i.length){if(i[p]==='"'){p++;n=0;break}i[p]==="\\"&&p++;t+=i[p]}if(n)throw new PathError(`Unterminated quote at index ${n}`,e)}if(!t)throw new PathError(`Missing parameter name at index ${p}`,e);return t}while(p<i.length){const e=i[p];const t=s[e];t?c.push({type:t,index:p++,value:e}):e==="\\"?c.push({type:"escape",index:p++,value:i[p++]}):e===":"?c.push({type:"param",index:p++,value:l()}):e==="*"?c.push({type:"wildcard",index:p++,value:l()}):c.push({type:"char",index:p++,value:e})}c.push({type:"end",index:p,value:""});function f(t){const n=[];while(true){const r=c[u++];if(r.type===t)break;if(r.type!=="char"&&r.type!=="escape")if(r.type!=="param"&&r.type!=="wildcard"){if(r.type!=="{")throw new PathError(`Unexpected ${r.type} at index ${r.index}, expected ${t}`,e);n.push({type:"group",tokens:f("}")})}else n.push({type:r.type,name:r.value});else{let e=r.value;let t=c[u];while(t.type==="char"||t.type==="escape"){e+=t.value;t=c[++u]}n.push({type:"text",value:a(e)})}}return n}return new TokenData(f("end"),e)}function p(e,n={}){const{encode:r=encodeURIComponent,delimiter:o=t}=n;const s=typeof e==="object"?e:c(e,n);const a=u(s.tokens,o,r);return function(e={}){const[t,...n]=a(e);if(n.length)throw new TypeError(`Missing parameters: ${n.join(", ")}`);return t}}function u(e,t,n){const r=e.map((e=>l(e,t,n)));return e=>{const t=[""];for(const n of r){const[r,...o]=n(e);t[0]+=r;t.push(...o)}return t}}function l(e,t,r){if(e.type==="text")return()=>[e.value];if(e.type==="group"){const n=u(e.tokens,t,r);return e=>{const[t,...r]=n(e);return r.length?[""]:[t]}}const o=r||n;return e.type==="wildcard"&&r!==false?n=>{const r=n[e.name];if(r==null)return["",e.name];if(!Array.isArray(r)||r.length===0)throw new TypeError(`Expected "${e.name}" to be a non-empty array`);return[r.map(((t,n)=>{if(typeof t!=="string")throw new TypeError(`Expected "${e.name}/${n}" to be a string`);return o(t)})).join(t)]}:t=>{const n=t[e.name];if(n==null)return["",e.name];if(typeof n!=="string")throw new TypeError(`Expected "${e.name}" to be a string`);return[o(n)]}}function f(e,r={}){const{decode:o=decodeURIComponent,delimiter:s=t}=r;const{regexp:a,keys:i}=h(e,r);const c=i.map((e=>o===false?n:e.type==="param"?o:e=>e.split(s).map(o)));return function(e){const t=a.exec(e);if(!t)return false;const n=t[0];const r=Object.create(null);for(let e=1;e<t.length;e++){if(t[e]===void 0)continue;const n=i[e-1];const o=c[e-1];r[n.name]=o(t[e])}return{path:n,params:r}}}function h(e,n={}){const{delimiter:r=t,end:o=true,sensitive:s=false,trailing:a=true}=n;const p=[];const u=s?"":"i";const l=[];for(const t of y(e,[])){const e=typeof t==="object"?t:c(t,n);for(const t of d(e.tokens,0,[]))l.push(g(t,r,p,e.originalPath))}let f=`^(?:${l.join("|")})`;a&&(f+=`(?:${i(r)}$)?`);f+=o?"$":`(?=${i(r)}|$)`;const h=new RegExp(f,u);return{regexp:h,keys:p}}function y(e,t){if(Array.isArray(e))for(const n of e)y(n,t);else t.push(e);return t}function*d(e,t,n){if(t===e.length)return yield n;const r=e[t];if(r.type==="group")for(const o of d(r.tokens,0,n.slice()))yield*d(e,t+1,o);else n.push(r);yield*d(e,t+1,n)}function g(e,t,n,r){let o="";let s="";let a=true;for(const c of e)if(c.type!=="text")if(c.type!=="param"&&c.type!=="wildcard");else{if(!a&&!s)throw new PathError(`Missing text before "${c.name}" ${c.type}`,r);c.type==="param"?o+=`(${m(t,a?"":s)}+)`:o+="([\\s\\S]+)";n.push(c);s="";a=false}else{o+=i(c.value);s+=c.value;a||(a=c.value.includes(t))}return o}function m(e,t){return t.length<2?e.length<2?`[^${i(e+t)}]`:`(?:(?!${i(e)})[^${i(t)}])`:e.length<2?`(?:(?!${i(t)})[^${i(e)}])`:`(?:(?!${i(t)}|${i(e)})[\\s\\S])`}function $(e){let t="";let n=0;function r(t){const r=x(t)&&v(e[n]);return r?t:JSON.stringify(t)}while(n<e.length){const o=e[n++];if(o.type!=="text")if(o.type!=="group")if(o.type!=="param"){if(o.type!=="wildcard")throw new TypeError(`Unknown token type: ${o.type}`);t+=`*${r(o.name)}`}else t+=`:${r(o.name)}`;else t+=`{${$(o.tokens)}}`;else t+=a(o.value)}return t}function w(e){return $(e.tokens)}function x(e){const[t,...n]=e;return r.test(t)&&n.every((e=>o.test(e)))}function v(e){return!e||e.type!=="text"||!o.test(e.value[0])}const k=e.__esModule;const E=e.PathError,T=e.TokenData,P=e.parse,b=e.compile,D=e.match,j=e.pathToRegexp,R=e.stringify;export{E as PathError,T as TokenData,k as __esModule,b as compile,e as default,D as match,P as parse,j as pathToRegexp,R as stringify};

